# Basic types
[TYPEDEF basicType INT]
[TYPEDEF type STRUCT{typ:basicType,val:ANY}]
[TYPEDEF arrayType STRUCT{elem:type}]
[TYPEDEF mapType STRUCT{key:type, val:type}]
[TYPEDEF funcType STRUCT{pars:ARRAY{type}, ret: type}]
[TYPEDEF structField STRUCT{name:STRING, typ:type}]
[TYPEDEF structType ARRAY{structField}]
[TYPEDEF nil NULL]
[TYPEDEF mulType ARRAY{type}]

[CONSTDEF INT 0]
[CONSTDEF BYTE 1]
[CONSTDEF FLOAT 2]
[CONSTDEF BOOL 3]
[CONSTDEF STRING 4]
[CONSTDEF ARRAY 5]
[CONSTDEF MAP 6]
[CONSTDEF FUNCTION 7]
[CONSTDEF STRUCT 8]
[CONSTDEF _NULL 9]
[CONSTDEF ANY 10]

# Special
[CONSTDEF ALL 11]
[CONSTDEF VARIADIC 12]
[CONSTDEF IDENT 13]
[CONSTDEF INVALID 14]
[CONSTDEF MULTYPE 15]

[FUNC _INT [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST INT]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]
[FUNC _BYTE [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST BYTE]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]
[FUNC _FLOAT [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST FLOAT]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]
[FUNC _BOOL [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST BOOL]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]
[FUNC _STRING [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST STRING]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]
[FUNC __ARRAY [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST ARRAY]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]
[FUNC _MAP [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST MAP]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]
[FUNC _FUNCTION [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST FUNCTION]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]
[FUNC _STRUCT [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST STRUCT]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]
[FUNC _NULL [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST _NULL]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]
[FUNC _ANY [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST ANY]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]
[FUNC _ALL [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST ALL]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]
[FUNC _VARIADIC [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST VARIADIC]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]
[FUNC _IDENT [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST IDENT]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]
[FUNC _INVALID [RETURNS type] [DEFINE out [MAKE type]] [SET [VAR out] typ [CONST INVALID]] [SET [VAR out] val [ANY NULL]] [RETURN [VAR out]]]

[FUNC _ARRAY [PARAM elTyp type] [RETURNS type]
  [DEFINE out [MAKE arrayType]]
  [SET [VAR out] elem [VAR elTyp]]
  [DEFINE val [MAKE type]]
  [SET [VAR val] typ [CONST ARRAY]]
  [SET [VAR val] val [ANY [VAR out]]]
  [RETURN [VAR val]]
]

[FUNC MAP [PARAM kTyp type] [PARAM vTyp type] [RETURNS type]
  [DEFINE out [MAKE mapType]]
  [SET [VAR out] key [VAR kTyp]]
  [SET [VAR out] val [VAR vTyp]]
  [DEFINE val [MAKE type]]
  [SET [VAR val] typ [CONST MAP]]
  [SET [VAR val] val [ANY [VAR out]]]
  [RETURN [VAR val]]
]

[FUNC FUNCTION [PARAM pars ARRAY{type}] [PARAM retTyp type] [RETURNS type]
  [DEFINE out [MAKE funcType]]
  [SET [VAR out] pars [VAR pars]]
  [SET [VAR out] ret [VAR retTyp]]
  [DEFINE val [MAKE type]]
  [SET [VAR val] typ [CONST FUNCTION]]
  [SET [VAR val] val [ANY [VAR out]]]
  [RETURN [VAR val]]
]

[FUNC FIELD [PARAM name STRING] [PARAM typ type] [RETURNS structField]
  [DEFINE out [MAKE structField]]
  [SET [VAR out] name [VAR name]]
  [SET [VAR out] typ [VAR typ]]
  [RETURN [VAR out]]
]

[FUNC STRUCT [PARAM fields ARRAY{structField}] [RETURNS type]
  [DEFINE val [MAKE type]]
  [SET [VAR val] typ [CONST STRUCT]]
  [SET [VAR val] val [ANY [VAR fields]]]
  [RETURN [VAR val]]
]

[FUNC MULTYPE [PARAM typs ARRAY{type}] [RETURNS type]
  [DEFINE out [MAKE type]]
  [SET [VAR out] typ [CONST MULTYPE]]
  [SET [VAR out] val [ANY [VAR typs]]]
  [RETURN [VAR out]]
]

[FUNC TSTRING [PARAM t type] [RETURNS STRING]
  [IF [CANCAST [GET [VAR t] val] nil]
    [SWITCH [GET [VAR t] typ]
      [CASE [CONST INT] [RETURN "INT"]]
      [CASE [CONST BYTE] [RETURN "BYTE"]]
      [CASE [CONST FLOAT] [RETURN "FLOAT"]]
      [CASE [CONST BOOL] [RETURN "BOOL"]]
      [CASE [CONST STRING] [RETURN "STRING"]]
      [CASE [CONST ARRAY] [RETURN "ARRAY"]]
      [CASE [CONST MAP] [RETURN "MAP"]]
      [CASE [CONST FUNCTION] [RETURN "FUNCTION"]]
      [CASE [CONST STRUCT] [RETURN "STRUCT"]]
      [CASE [CONST _NULL] [RETURN "NULL"]]
      [CASE [CONST ANY] [RETURN "ANY"]]
    ]
  ]

  [SWITCH [GET [VAR t] typ]
    [CASE [CONST ARRAY] 
      [DEFINE e [GET [CAST [GET [VAR t] val] arrayType] elem]]
      [RETURN [CONCAT "ARRAY{" [TSTRING [VAR e]] "}"]]
    ]

    [CASE [CONST MAP] 
      [DEFINE m [CAST [GET [VAR t] val] mapType]]
      [DEFINE k [GET [VAR m] key]]
      [DEFINE v [GET [VAR m] val]]
      [RETURN [CONCAT "MAP{" [TSTRING [VAR k]] ", " [TSTRING [VAR v]] "}"]]
    ]

    [CASE [CONST FUNCTION] 
      [DEFINE m [CAST [GET [VAR t] val] funcType]]
      [DEFINE out "FUNC{"]
      [DEFINE pars [GET [VAR m] pars]]
      [DEFINE i 0]
      [WHILE [COMPARE [VAR i] < [LENGTH [VAR pars]]]
        [IF [COMPARE [VAR i] > 0]
          [DEFINE out [CONCAT [VAR out] ", "]]
        ]
        [DEFINE out [CONCAT [VAR out] [TSTRING [INDEX [VAR pars] [VAR i]]]]]
        [DEFINE i [MATH [VAR i] + 1]]
      ]
      [RETURN [CONCAT [VAR out] "}" [TSTRING [GET [VAR m] ret]]]]
    ]

    [CASE [CONST STRUCT] 
      [DEFINE fields [CAST [GET [VAR t] val] structType]]
      [DEFINE out "STRUCT{"]
      [DEFINE i 0]
      [WHILE [COMPARE [VAR i] < [LENGTH [VAR fields]]]
        [DEFINE f [INDEX [VAR fields] [VAR i]]]
        [IF [COMPARE [VAR i] > 0]
          [DEFINE out [CONCAT [VAR out] ", "]]
        ]
        [DEFINE out [CONCAT [VAR out] [GET [VAR f] name] ":" [TSTRING [GET [VAR f] typ]]]]
        [DEFINE i [MATH [VAR i] + 1]]
      ]
      [RETURN [CONCAT [VAR out] "}"]]
    ]

    [CASE [CONST MULTYPE]
      [DEFINE out ""]
      [DEFINE vals [CAST [GET [VAR t] val] mulType]]
      [DEFINE i 0]
      [WHILE [COMPARE [VAR i] < [LENGTH [VAR vals]]]
        [IF [COMPARE [VAR i] > 0]
          [DEFINE out [CONCAT [VAR out] "|"]]
        ]
        [DEFINE out [CONCAT [VAR out] [TSTRING [INDEX [VAR vals] [VAR i]]]]]
      ]
    ]
  ]
  
  [RETURN "unknown"]
]

[FUNC TEQUAL [PARAM a type] [PARAM b type] [RETURNS BOOL]
  [IF [CANCAST [GET [VAR a] val] nil]
    [IF [COMPARE [GET [VAR a] typ] == [CONST ALL]]
      [RETURN TRUE]
    ]
    [RETURN [COMPARE [GET [VAR a] typ] == [GET [VAR b] typ]]]
  ]

  [IF [COMPARE [GET [VAR a] typ] != [GET [VAR b] typ]]
    [RETURN FALSE]
  ]

  [SWITCH [GET [VAR a] typ]
    [CASE [CONST ARRAY] 
      [RETURN [TEQUAL [GET [CAST [GET [VAR a] val] arrayType] elem] [GET [CAST [GET [VAR b] val] arrayType] elem]]]
    ]

    [CASE [CONST MAP] 
      [DEFINE x [CAST [GET [VAR a] val] mapType]]
      [DEFINE y [CAST [GET [VAR b] val] mapType]]
      [DEFINE ke [TEQUAL [GET [VAR x] key] [GET [VAR y] key]]]
      [DEFINE ve [TEQUAL [GET [VAR x] val] [GET [VAR y] val]]]
      [RETURN [AND [VAR ke] [VAR ve]]]
    ]

    [CASE [CONST FUNCTION] 
      [DEFINE x [CAST [GET [VAR a] val] funcType]]
      [DEFINE y [CAST [GET [VAR b] val] funcType]]
      [IF [NOT [TEQUAL [GET [VAR x] ret] [GET [VAR y] ret]]]
        [RETURN FALSE]
      ]
      [IF [COMPARE [LENGTH [GET [VAR x] pars]] != [LENGTH [GET [VAR y] pars]]]
        [RETURN FALSE]
      ]
      [DEFINE i 0]
      [WHILE [COMPARE [VAR i] < [LENGTH [GET [VAR x] pars]]]
        [IF [NOT [TEQUAL [INDEX [GET [VAR x] pars] [VAR i]] [INDEX [GET [VAR y] pars] [VAR i]]]]
          [RETURN FALSE]
        ]
        [DEFINE i [MATH [VAR i] + 1]]
      ]
      [RETURN TRUE]
    ]

    [CASE [CONST STRUCT] 
      [DEFINE x [CAST [GET [VAR a] val] structType]]
      [DEFINE y [CAST [GET [VAR b] val] structType]]
      [DEFINE i 0]
      [IF [COMPARE [LENGTH [VAR x]] != [LENGTH [VAR y]]]
        [RETURN FALSE]
      ]
      [WHILE [COMPARE [VAR i] < [LENGTH [VAR x]]]
        [DEFINE d [INDEX [VAR x] [VAR i]]]
        [DEFINE e [INDEX [VAR y] [VAR i]]]
        [IF [OR [COMPARE [GET [VAR d] name] != [GET [VAR e] name]] [NOT [TEQUAL [GET [VAR d] typ] [GET [VAR e] typ]]]]
          [RETURN FALSE]
        ]
        [DEFINE i [MATH [VAR i] + 1]]
      ]
      [RETURN TRUE]
    ]

    [CASE [CONST MULTYPE]
      [DEFINE vals [CAST [GET [VAR a] val] mulType]]
      [DEFINE i 0]
      [WHILE [COMPARE [VAR i] < [LENGTH [VAR vals]]]
        [IF [TEQUAL [INDEX [VAR vals] [VAR i]] [VAR b]]
          [RETURN TRUE]
        ]
        [DEFINE i [MATH [VAR i] + 1]]
      ]
      [RETURN FALSE]
    ]
  ]

  [RETURN FALSE]
]