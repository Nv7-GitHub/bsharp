[IMPORT "errors.bsp"]
[TYPEDEF pos STRUCT{char:INT,line:INT,file:STRING}]
[TYPEDEF token STRUCT{typ:INT,val:STRING,pos:pos}]
[CONSTDEF tokTypeNumber 0]
[CONSTDEF tokTypeString 1]
[CONSTDEF tokTypeLBrack 2]
[CONSTDEF tokTypeRBrack 3]
[CONSTDEF tokTypeIdent 4]
[CONSTDEF tokTypeByte 5]

[FUNC TOKEN [PARAM typ INT] [PARAM val STRING] [PARAM pos pos] [RETURNS token]
  [DEFINE out [MAKE token]]
  [SET [VAR out] typ [VAR typ]]
  [SET [VAR out] val [VAR val]]
  [SET [VAR out] pos [VAR pos]]
  [RETURN [VAR out]]
]

[TYPEDEF tokenizer STRUCT{tokens:ARRAY{token},pos:INT,char:INT,line:INT,code:STRING,file:STRING}]

# Tokenizer utils
[FUNC TOKIND [PARAM tokenizer tokenizer] [RETURNS INT] [RETURN [GET [VAR tokenizer] pos]]]

[FUNC TOKINCR [PARAM tokenizer tokenizer]
  # Check char
  [SET [VAR tokenizer] char [MATH [GET [VAR tokenizer] char] + 1]]
  [DEFINE char [INDEX [GET [VAR tokenizer] code] [TOKIND [VAR tokenizer]]]]
  [IF [COMPARE [VAR char] == '\n']
    [SET [VAR tokenizer] line [MATH [GET [VAR tokenizer] line] + 1]]
    [SET [VAR tokenizer] char 1]
  ]

  # Incr
  [SET [VAR tokenizer] pos [MATH [GET [VAR tokenizer] pos] + 1]]
]

[FUNC POS [PARAM tok tokenizer] [RETURNS pos]
  [DEFINE out [MAKE pos]]
  [SET [VAR out] char [GET [VAR tok] char]]
  [SET [VAR out] line [GET [VAR tok] line]]
  [SET [VAR out] file [GET [VAR tok] file]]
  [RETURN [VAR out]]
]

[FUNC POSSTR [PARAM pos pos] [RETURNS STRING]
  [RETURN [CONCAT [GET [VAR pos] file] ":" [STRING [GET [VAR pos] line]] ":" [STRING [GET [VAR pos] char]]]]
]

[FUNC ERR [PARAM pos pos] [PARAM msg STRING] [RETURNS ANY]
  [RETURN [ERROR [CONCAT [POSSTR [VAR pos]] ": " [VAR msg]]]]
]

[FUNC ADDTOK [PARAM tok tokenizer] [PARAM token token]
  [APPEND [GET [VAR tok] tokens] [VAR token]]
]

[FUNC ADDNUM [PARAM tok tokenizer]
  [DEFINE pos [POS [VAR tok]]]
  [DEFINE code [GET [VAR tok] code]]
  [DEFINE running TRUE]
  [DEFINE val ""]
  [WHILE [AND [COMPARE [TOKIND [VAR tok]] < [LENGTH [VAR code]]] [VAR running]]
    [DEFINE char [INDEX [VAR code] [TOKIND [VAR tok]]]]
    [DEFINE isNum FALSE]
    [SWITCH [VAR char]
      [CASE '0' [DEFINE isNum TRUE]]
      [CASE '1' [DEFINE isNum TRUE]]
      [CASE '2' [DEFINE isNum TRUE]]
      [CASE '3' [DEFINE isNum TRUE]]
      [CASE '4' [DEFINE isNum TRUE]]
      [CASE '5' [DEFINE isNum TRUE]]
      [CASE '6' [DEFINE isNum TRUE]]
      [CASE '7' [DEFINE isNum TRUE]]
      [CASE '8' [DEFINE isNum TRUE]]
      [CASE '9' [DEFINE isNum TRUE]]
      [CASE '.' [DEFINE isNum TRUE]]
      [CASE '-' [DEFINE isNum TRUE]]
    ]
    [IF [VAR isNum]
      [DEFINE val [CONCAT [VAR val] [STRING [VAR char]]]]
      [TOKINCR [VAR tok]]
    ELSE
      [DEFINE running FALSE]
    ]
  ]
  [ADDTOK [VAR tok] [TOKEN [CONST tokTypeNumber] [VAR val] [VAR pos]]]
]

[FUNC ADDSTR [PARAM tok tokenizer]
  [TOKINCR [VAR tok]] # Eat "
  [DEFINE pos [POS [VAR tok]]]
  [DEFINE code [GET [VAR tok] code]]
  [DEFINE running TRUE]
  [DEFINE val ""]
  [WHILE [AND [COMPARE [TOKIND [VAR tok]] < [LENGTH [VAR code]]] [VAR running]]
    [DEFINE char [INDEX [VAR code] [TOKIND [VAR tok]]]]
    [IF [COMPARE [VAR char] == '"']
      # End
      [TOKINCR [VAR tok]]
      [DEFINE running FALSE]
    ELSE
      # Escape codes
      [IF [COMPARE [VAR char] == '\\']
        [TOKINCR [VAR tok]]
        [DEFINE char [INDEX [VAR code] [TOKIND [VAR tok]]]] # Next char
        [SWITCH [VAR char]
          [CASE '"' [DEFINE val [CONCAT [VAR val] "\""]]]
          [CASE 't' [DEFINE val [CONCAT [VAR val] "\t"]]]
          [CASE 'n' [DEFINE val [CONCAT [VAR val] "\n"]]]
          [CASE '\\' [DEFINE val [CONCAT [VAR val] "\\"]]]
        ]
        [TOKINCR [VAR tok]]
      ELSE
        # Value
        [DEFINE val [CONCAT [VAR val] [STRING [VAR char]]]]
        [TOKINCR [VAR tok]]
      ]
    ]
  ]
  [ADDTOK [VAR tok] [TOKEN [CONST tokTypeString] [VAR val] [VAR pos]]]
]

[FUNC ADDBYTE [PARAM tok tokenizer] [RETURNS ANY]
  [TOKINCR [VAR tok]] # Eat '
  [DEFINE pos [POS [VAR tok]]]
  [DEFINE val ' ']

  [DEFINE code [GET [VAR tok] code]]
  [DEFINE char [INDEX [VAR code] [TOKIND [VAR tok]]]]
  [IF [COMPARE [VAR char] == '\\']
    [TOKINCR [VAR tok]] # Eat backslash
    [DEFINE char [INDEX [VAR code] [TOKIND [VAR tok]]]]
    [SWITCH [VAR char]
      [CASE '\'' [DEFINE val '\'']]
      [CASE 'n' [DEFINE val '\n']]
      [CASE '\\' [DEFINE val '\\']]
      [CASE 't' [DEFINE val '\t']]
      [DEFAULT [RETURN [ERR [POS [VAR tok]] "invalid escape code"]]]
    ]
    [TOKINCR [VAR tok]] # Eat escape code
  ELSE
    [DEFINE val [VAR char]]
    [TOKINCR [VAR tok]] # Eat char
  ]
  
  [DEFINE char [INDEX [VAR code] [TOKIND [VAR tok]]]]
  [IF [COMPARE [VAR char] != '\'']
    [RETURN [ERR [POS [VAR tok]] "expected closing single quote"]]
  ]
  [TOKINCR [VAR tok]]

  [ADDTOK [VAR tok] [TOKEN [CONST tokTypeByte] [STRING [VAR val]] [VAR pos]]]

  [RETURN [ANY NULL]]
]

[FUNC ADDIDENT [PARAM tok tokenizer]
  [DEFINE pos [POS [VAR tok]]]
  [DEFINE code [GET [VAR tok] code]]
  [DEFINE running TRUE]
  [DEFINE val ""]
  [DEFINE bracks 0]
  [WHILE [AND [COMPARE [TOKIND [VAR tok]] < [LENGTH [VAR code]]] [VAR running]]
    [DEFINE char [INDEX [VAR code] [TOKIND [VAR tok]]]]
    [SWITCH [VAR char]
      [CASE '{' [DEFINE bracks [MATH [VAR bracks] + 1]]]
      [CASE '}' [DEFINE bracks [MATH [VAR bracks] - 1]]]
      [CASE ' ' [DEFINE running FALSE]]
      [CASE '\t' [DEFINE running FALSE]]
      [CASE '\n' [DEFINE running FALSE]]
      [CASE ']' [DEFINE running FALSE]]
    ]

    [IF [VAR running]
      [TOKINCR [VAR tok]]
      [DEFINE val [CONCAT [VAR val] [STRING [VAR char]]]]
    ]
  ]
  [ADDTOK [VAR tok] [TOKEN [CONST tokTypeIdent] [VAR val] [VAR pos]]]
]

[FUNC TOKENIZE [PARAM file STRING] [PARAM code STRING] [RETURNS option] # ARRAY{token}
  [DEFINE out [MAKE tokenizer]]
  [SET [VAR out] tokens [MAKE ARRAY{token}]]
  [SET [VAR out] file [VAR file]]
  [SET [VAR out] code [VAR code]]
  [SET [VAR out] pos 0]
  [SET [VAR out] char 1]
  [SET [VAR out] line 1]
  [WHILE [COMPARE [TOKIND [VAR out]] < [LENGTH [VAR code]]]
    [DEFINE char [INDEX [VAR code] [TOKIND [VAR out]]]]
    [SWITCH [VAR char]
      [CASE '['
        [ADDTOK [VAR out] [TOKEN [CONST tokTypeLBrack] "[" [POS [VAR out]]]]
        [TOKINCR [VAR out]]
      ]

      [CASE ']'
        [ADDTOK [VAR out] [TOKEN [CONST tokTypeRBrack] "]" [POS [VAR out]]]]
        [TOKINCR [VAR out]]
      ]

      [CASE '0' [ADDNUM [VAR out]]]
      [CASE '1' [ADDNUM [VAR out]]]
      [CASE '2' [ADDNUM [VAR out]]]
      [CASE '3' [ADDNUM [VAR out]]]
      [CASE '4' [ADDNUM [VAR out]]]
      [CASE '5' [ADDNUM [VAR out]]]
      [CASE '6' [ADDNUM [VAR out]]]
      [CASE '7' [ADDNUM [VAR out]]]
      [CASE '8' [ADDNUM [VAR out]]]
      [CASE '9' [ADDNUM [VAR out]]]
      [CASE '-' 
        # Check if next is num
        [DEFINE next [INDEX [VAR code] [MATH [TOKIND [VAR out]] + 1]]]
        [DEFINE isNum FALSE]
        [SWITCH [VAR next]
          [CASE '0' [DEFINE isNum TRUE]]
          [CASE '1' [DEFINE isNum TRUE]]
          [CASE '2' [DEFINE isNum TRUE]]
          [CASE '3' [DEFINE isNum TRUE]]
          [CASE '4' [DEFINE isNum TRUE]]
          [CASE '5' [DEFINE isNum TRUE]]
          [CASE '6' [DEFINE isNum TRUE]]
          [CASE '7' [DEFINE isNum TRUE]]
          [CASE '8' [DEFINE isNum TRUE]]
          [CASE '9' [DEFINE isNum TRUE]]
        ]
        [IF [VAR isNum]
          [ADDNUM [VAR out]]
        ELSE
          [ADDIDENT [VAR out]]
        ]
      ]
      [CASE '"' [ADDSTR [VAR out]]]

      [CASE '\''
        [DEFINE err [ADDBYTE [VAR out]]]
        [IF [CANCAST [VAR err] error]
          [RETURN [VAR err]]
        ]
      ]

      # Ignore whitespace
      [CASE '\t' [TOKINCR [VAR out]]]
      [CASE ' ' [TOKINCR [VAR out]]]
      [CASE '\n' [TOKINCR [VAR out]]]

      [DEFAULT
        [ADDIDENT [VAR out]]
      ]
    ]
  ]
  [RETURN [ANY [GET [VAR out] tokens]]]
]
