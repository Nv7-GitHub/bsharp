[IMPORT "bstar/parser.bsp"]
[IMPORT "errors.bsp"]
[IMPORT "bstar/funcs/funcs.bsp"]

[FUNC evalNode [PARAM node node] [RETURNS ANY]
  [SWITCH [GET [VAR node] kind]
    [CASE [CONST nodeKindTag]
      # Check for valid tag syntax
      [DEFINE args [CAST [GET [VAR node] val] ARRAY{node}]]
      [IF [COMPARE [LENGTH [VAR args]] == 0]
        [RETURN [NODE_ERR [VAR node] "tag must have at least 1 argument"]]
      ]
      [IF [COMPARE [GET [INDEX [VAR args] 0] kind] != [CONST nodeKindString]]
        [RETURN [NODE_ERR [INDEX [VAR args] 0] "expected STRING for tag name"]]
      ]

      # Get name
      [DEFINE name [CAST [GET [INDEX [VAR args] 0] val] STRING]]

      # Check if blk, if so do that without building args
      [IF [EXISTS [VAR blks] [VAR name]]
        [DEFINE blk [GET [VAR blks] [VAR name]]]
        [RETURN [CALL [VAR blk] [VAR args]]]
      ]

      # Build params
      [DEFINE pars [MAKE ARRAY{node}]]
      [DEFINE i 1]
      [WHILE [COMPARE [VAR i] < [LENGTH [VAR args]]]
        [DEFINE err [evalNode [INDEX [VAR args] [VAR i]]]]
        [IF [CANCAST [VAR err] error]
          [RETURN [VAR err]]
        ]
        [APPEND [VAR pars] [CAST [VAR err] node]]
        [DEFINE i [MATH [VAR i] + 1]]
      ]

      # Call
      [IF [NOT [EXISTS [VAR blds] [VAR name]]]
        [RETURN [NODE_ERR [VAR node] [CONCAT "unknown tag: \"" [VAR name] "\""]]]
      ]
      [DEFINE bld [GET [VAR blds] [VAR name]]]
      [RETURN [CALL [VAR bld] [VAR pars]]]
    ]

    [CASE [CONST nodeKindArray]
      [DEFINE args [MAKE ARRAY{node}]]
      [DEFINE curr [CAST [GET [VAR node] val] ARRAY{node}]]
      [DEFINE i 0]
      [WHILE [COMPARE [VAR i] < [LENGTH [VAR curr]]] 
        [DEFINE err [evalNode [VAR node]]]
        [IF [CANCAST [VAR err] error]
          [RETURN [VAR err]]
        ]
        [APPEND [VAR args] [CAST [VAR err] node]]
        [DEFINE i [MATH [VAR i] + 1]]
      ]
      [DEFINE out [MAKE node]]
      [SET [VAR out] kind [CONST nodeKindArray]]
      [SET [VAR out] val [ANY [VAR args]]]
      [RETURN [ANY [VAR out]]]
    ]
  ]
  [RETURN [ANY [VAR node]]]
]

[FUNC INTERP [PARAM parsed ARRAY{node}] [RETURNS ARRAY{node}]
  [DEFINE out [MAKE ARRAY{node}]]
  [DEFINE i 0]
  [WHILE [COMPARE [VAR i] < [LENGTH [VAR parsed]]]
    [DEFINE err [evalNode [INDEX [VAR parsed] [VAR i]]]]
    [IF [CANCAST [VAR err] error]
      [FAIL [VAR err]]
    ]
    [APPEND [VAR out] [CAST [VAR err] node]]
    [DEFINE i [MATH [VAR i] + 1]]
  ]
  [RETURN [VAR out]]
]