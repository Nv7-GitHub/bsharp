[CONSTDEF nodeKindString 0]
[CONSTDEF nodeKindTag 1]
[CONSTDEF nodeKindInt 2]
[CONSTDEF nodeKindFloat 3]
[CONSTDEF nodeKindArray 4]
[TYPEDEF node STRUCT{kind:INT, val: ANY}]

[FUNC NODE_STRING [PARAM node node] [RETURNS STRING]
  [SWITCH [GET [VAR node] kind]
    [CASE [CONST nodeKindString]
      [RETURN [CONCAT "\"" [CAST [GET [VAR node] val] STRING] "\""]]
    ]

    [CASE [CONST nodeKindInt]
      [RETURN [STRING [CAST [GET [VAR node] val] INT]]]
    ]

    [CASE [CONST nodeKindFloat]
      [RETURN [STRING [CAST [GET [VAR node] val] FLOAT]]]
    ]

    [CASE [CONST nodeKindArray]
      [DEFINE out "[ARRAY"]
      [DEFINE vals [CAST [GET [VAR node] val] ARRAY{node}]]
      [DEFINE i 0]
      [WHILE [COMPARE [VAR i] < [LENGTH [VAR vals]]]
        [DEFINE n [NODE_STRING [INDEX [VAR vals] [VAR i]]]]
        [DEFINE out [CONCAT [VAR out] " " [VAR n]]]
        [DEFINE i [MATH [VAR i] + 1]]
      ]
      [RETURN [CONCAT [VAR out] "]"]]
    ]

    [CASE [CONST nodeKindTag]
      [DEFINE out "["]
      [DEFINE vals [CAST [GET [VAR node] val] ARRAY{node}]]
      [DEFINE i 0]
      [WHILE [COMPARE [VAR i] < [LENGTH [VAR vals]]]
        [DEFINE n [NODE_STRING [INDEX [VAR vals] [VAR i]]]]
        [IF [COMPARE [VAR i] > 0]
          [DEFINE out [CONCAT [VAR out] " "]]
        ]
        [DEFINE out [CONCAT [VAR out] [VAR n]]]
        [DEFINE i [MATH [VAR i] + 1]]
      ]
      [RETURN [CONCAT [VAR out] "]"]]
    ]
  ]
  [RETURN "unknown"]
]

[FUNC parseDef [PARAM code STRING] [RETURNS STRUCT{val:node, len:INT}]
  [IF [OR [COMPARE [INDEX [VAR code] 0] == ' '] [COMPARE [INDEX [VAR code] 0] == '\n']]
    [DEFINE node [MAKE node]]
    [SET [VAR node] kind [CONST nodeKindString]]
    [SET [VAR node] val [ANY [STRING [INDEX [VAR code] 0]]]]

    [DEFINE out [MAKE STRUCT{val:node, len:INT}]]
    [SET [VAR out] len 1]
    [SET [VAR out] val [VAR node]]
    [RETURN [VAR out]]
  ]

  [IF [COMPARE [INDEX [VAR code] 0] == '"']
    [DEFINE i 1]
    [DEFINE backslash FALSE]
    [DEFINE skip FALSE]
    [DEFINE val ""]
    [WHILE [COMPARE [VAR i] < [LENGTH [VAR code]]]
      [DEFINE char [INDEX [VAR code] [VAR i]]]
      [IF [VAR backslash]
        [SWITCH [VAR char]
          [CASE 'n' 
            [DEFINE val [CONCAT [VAR val] "\n"]]
            [DEFINE backslash FALSE]
            [DEFINE skip TRUE]
          ]

          [CASE 't' 
            [DEFINE val [CONCAT [VAR val] "\t"]]
            [DEFINE backslash FALSE]
            [DEFINE skip TRUE]
          ]

          [CASE '"' 
            [DEFINE val [CONCAT [VAR val] "\""]]
            [DEFINE backslash FALSE]
            [DEFINE skip TRUE]
          ]

          [CASE '\\' 
            [DEFINE val [CONCAT [VAR val] "\\"]]
            [DEFINE backslash FALSE]
            [DEFINE skip TRUE]
          ]
        ]
      ]

      [IF [COMPARE [VAR char] == '"']
        [DEFINE node [MAKE node]]
        [SET [VAR node] kind [CONST nodeKindString]]
        [SET [VAR node] val [ANY [VAR val]]]

        [DEFINE out [MAKE STRUCT{val:node, len:INT}]]
        [SET [VAR out] len [MATH [VAR i] + 1]]
        [SET [VAR out] val [VAR node]]
        [RETURN [VAR out]]
      ]

      [IF [NOT [VAR skip]]
        [DEFINE val [CONCAT [VAR val] [STRING [VAR char]]]]
      ELSE
        [DEFINE skip FALSE]
      ]

      [DEFINE i [MATH [VAR i] + 1]]
    ]
  ]

  # Is function def?
  [IF [COMPARE [INDEX [VAR code] 0] == '[']
    # parse function def
    [DEFINE i 1]
    [DEFINE nodes [MAKE ARRAY{node}]]
    [WHILE [AND [COMPARE [VAR i] < [LENGTH [VAR code]]] [COMPARE [INDEX [VAR code] [VAR i]] != ']']]
      [DEFINE val [parseDef [SLICE [VAR code] [VAR i] [LENGTH [VAR code]]]]]
      [APPEND [VAR nodes] [GET [VAR val] val]]
      [DEFINE i [MATH [VAR i] + [GET [VAR val] len]]]

      # Get rid of spaces
      [WHILE [AND [COMPARE [VAR i] < [LENGTH [VAR code]]] [OR [COMPARE [INDEX [VAR code] [VAR i]] == ' '] [COMPARE [INDEX [VAR code] [VAR i]] == '\n']]]
        [DEFINE i [MATH [VAR i] + 1]]
      ]
    ]

    [DEFINE node [MAKE node]]
    [SET [VAR node] kind [CONST nodeKindTag]]
    [SET [VAR node] val [ANY [VAR nodes]]]
    [DEFINE out [MAKE STRUCT{val:node, len:INT}]]
    [SET [VAR out] val [VAR node]]
    [SET [VAR out] len [MATH [VAR i] + 1]]
    [RETURN [VAR out]]
  ]

  # parse string/int/float
  [DEFINE i 0]
  [DEFINE val ""]
  [WHILE [COMPARE [VAR i] < [LENGTH [VAR code]]]
    [DEFINE char [INDEX [VAR code] [VAR i]]]

    [SWITCH [VAR char]
      [CASE '['
        [DEFINE out [MAKE STRUCT{val:node, len:INT}]]
        [SET [VAR out] len [VAR i]]
        [SET [VAR out] val [nodeFromString [VAR val]]]
        [RETURN [VAR out]]
      ]

      [CASE ']'
        [DEFINE out [MAKE STRUCT{val:node, len:INT}]]
        [SET [VAR out] len [VAR i]]
        [SET [VAR out] val [nodeFromString [VAR val]]]
        [RETURN [VAR out]]
      ]

      [CASE ' '
        [DEFINE out [MAKE STRUCT{val:node, len:INT}]]
        [SET [VAR out] len [VAR i]]
        [SET [VAR out] val [nodeFromString [VAR val]]]
        [RETURN [VAR out]]
      ]

      [CASE '\n'
        [DEFINE out [MAKE STRUCT{val:node, len:INT}]]
        [SET [VAR out] len [VAR i]]
        [SET [VAR out] val [nodeFromString [VAR val]]]
        [RETURN [VAR out]]
      ]

      [CASE '"'
        [DEFINE out [MAKE STRUCT{val:node, len:INT}]]
        [SET [VAR out] len [VAR i]]
        [SET [VAR out] val [nodeFromString [VAR val]]]
        [RETURN [VAR out]]
      ]

      [CASE '\\' [DEFINE backslash TRUE]]

      [DEFAULT
        [DEFINE val [CONCAT [VAR val] [STRING [VAR char]]]]
      ]
    ]

    [DEFINE i [MATH [VAR i] + 1]]
  ]

  [DEFINE out [MAKE STRUCT{val:node, len:INT}]]
  [SET [VAR out] len [VAR i]]
  [SET [VAR out] val [nodeFromString [VAR val]]]
  [RETURN [VAR out]]
]

[FUNC nodeFromString [PARAM val STRING] [RETURNS node]
  # TODO: Check if its a float or int, and parse if it is
  [DEFINE out [MAKE node]]
  [SET [VAR out] kind [CONST nodeKindString]]
  [SET [VAR out] val [ANY [VAR val]]]
  [RETURN [VAR out]]
]

[FUNC parse [PARAM code STRING] [RETURNS ARRAY{node}]
  [DEFINE out [MAKE ARRAY{node}]]
  [DEFINE i 0]
  [WHILE [COMPARE [VAR i] < [LENGTH [VAR code]]]  
    [DEFINE def [parseDef [SLICE [VAR code] [VAR i] [LENGTH [VAR code]]]]]
    [APPEND [VAR out] [GET [VAR def] val]]
    #[PRINT [STRING [GET [VAR def] len]]]
    [DEFINE i [MATH [VAR i] + [GET [VAR def] len]]]
  ]
  [RETURN [VAR out]]
]